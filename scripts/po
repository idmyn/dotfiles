#!/usr/bin/env -S deno run --quiet --allow-all

import { $ } from "jsr:@david/dax@0.43.2";
import { z } from "npm:zod@3.25.60";
import { Temporal } from "npm:@js-temporal/polyfill@0.5.1";

const fetchPromise = $`jj git fetch`.quiet();

async function getRepoInfo(): Promise<
  { repoArg: string; owner: string; repo: string }
> {
  // Check if we're in a git repository
  const isGitRepo = await $`git rev-parse --git-dir`.noThrow().quiet()
    .then((r) => r.code === 0);

  let repoIdentifier: string;

  if (isGitRepo) {
    // In git repo, gh can auto-detect but we still need owner/repo for GraphQL
    repoIdentifier =
      (await $`gh repo view --json nameWithOwner --jq '.nameWithOwner'`.text())
        .trim();
  } else {
    // Not in git repo, get from jj
    const remoteListOutput = await $`jj git remote list`.text();
    let originUrl = "";

    for (const line of remoteListOutput.trim().split("\n")) {
      const [remoteName, remoteUrl] = line.split(/\s+/);
      if (remoteName === "origin") {
        originUrl = remoteUrl;
        break;
      }
    }

    if (!originUrl) {
      console.error('Error: No "origin" remote found in jj git remote list');
      Deno.exit(1);
    }

    // Parse GitHub URL (SSH or HTTPS)
    const sshMatch = originUrl.match(/git@github\.com:(.+?)(?:\.git)?$/);
    const httpsMatch = originUrl.match(
      /https:\/\/github\.com\/(.+?)(?:\.git)?$/,
    );

    if (sshMatch) {
      repoIdentifier = sshMatch[1];
    } else if (httpsMatch) {
      repoIdentifier = httpsMatch[1];
    } else {
      console.error(`Error: Could not parse GitHub URL: ${originUrl}`);
      Deno.exit(1);
    }
  }

  const [owner, repo] = repoIdentifier.split("/");
  const repoArg = `--repo=${repoIdentifier}`;

  return { repoArg, owner, repo };
}

const PR = z.object({
  author: z.union([
    z.object({
      name: z.string(),
      login: z.string(),
      is_bot: z.literal(false),
    }),
    z.object({
      is_bot: z.literal(true),
    }),
  ]),
  title: z.string(),
  updatedAt: z.coerce.date(),
  headRefOid: z.string(),
});

const now = Temporal.Now.instant();
const today = Temporal.Now.plainDateISO();
const lastWeek = today.subtract({ weeks: 3 }).toString();

const updatedAtFilter = `updated:>${lastWeek}`;

const { repoArg } = await getRepoInfo();

const prs = PR.array().parse(
  JSON.parse(
    await $`gh pr list ${repoArg} --search=${updatedAtFilter} --json="author,title,updatedAt,headRefOid"`
      .text(),
  ),
);

// First collect the entries so we can calculate the max width of the first column
interface Entry {
  authorWhen: string;
  title: string;
  commit: string;
}

const entries: Entry[] = prs.flatMap((pr) => {
  if (pr.author.is_bot) {
    return [];
  }

  const updatedAt = Temporal.Instant.from(pr.updatedAt.toISOString());
  const duration = updatedAt.until(now);
  const daysAgo = Math.floor(duration.total({ unit: "days" }));
  const when = daysAgo === 0 ? "today" : `${daysAgo} days ago`;
  const author = pr.author.name || pr.author.login;

  return [
    {
      authorWhen: `${author} (${when})`,
      title: pr.title,
      commit: pr.headRefOid,
    },
  ];
});

// Determine the width for the first column so that all rows line up
const maxAuthorWhenLen = entries.reduce(
  (max, { authorWhen }) => Math.max(max, authorWhen.length),
  0,
);

// Build the list: "<padded authorWhen>  <title>\t<branch>"
const list = entries
  .map(({ authorWhen, title, commit }) => {
    const paddedAuthorWhen = authorWhen.padEnd(maxAuthorWhenLen + 2); // +2 for spacing between columns
    return `${paddedAuthorWhen}${title}\t${commit}`;
  })
  .join("\n");

// Pipe the list into fzf. We hide the branch column while keeping it in the
// line so we can recover it after selection.
const selectedLine = (
  await $`fzf --ansi --delimiter="\t" --with-nth=1`.stdinText(list).noThrow(130)
    .text()
).trim();

if (selectedLine.length === 0) {
  console.error("no PR selected");
  Deno.exit(1);
}

// Extract the commit (hidden second column)
const [, commit] = selectedLine.split("\t");

await fetchPromise;
await $`jj new ${commit}`.quiet();
