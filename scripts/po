#!/usr/bin/env -S deno run --quiet --allow-all

import { $ } from "jsr:@david/dax@0.43.2";
import { z } from "npm:zod@3.25.60";
import { Temporal } from "npm:@js-temporal/polyfill@0.5.1";

const fetchPromise = $`jj git fetch`.quiet();

// Detect if we're in a git repository
const isGitRepo = await $`git rev-parse --git-dir`.noThrow().quiet()
  .then((r) => r.code === 0);

const PR = z.object({
  author: z.union([
    z.object({
      name: z.string(),
      login: z.string(),
      is_bot: z.literal(false),
    }),
    z.object({
      is_bot: z.literal(true),
    }),
  ]),
  title: z.string(),
  updatedAt: z.coerce.date(),
  headRefOid: z.string(),
});

const now = Temporal.Now.instant();
const today = Temporal.Now.plainDateISO();
const lastWeek = today.subtract({ weeks: 3 }).toString();

const updatedAtFilter = `updated:>${lastWeek}`;

async function getOriginRemote(): Promise<string> {
  const output = await $`jj git remote list`.text();

  for (const line of output.trim().split("\n")) {
    const [remoteName, remoteUrl] = line.split(/\s+/);
    if (remoteName === "origin") {
      return remoteUrl;
    }
  }

  console.error('Error: No "origin" remote found in jj git remote list');
  console.error(
    "Please configure an origin remote with: jj git remote add origin <url>",
  );
  Deno.exit(1);
}

function parseGitHubUrl(url: string): string {
  // Handle SSH format: git@github.com:owner/repo.git
  const sshMatch = url.match(/git@github\.com:(.+?)(?:\.git)?$/);
  if (sshMatch) {
    return sshMatch[1];
  }

  // Handle HTTPS format: https://github.com/owner/repo.git
  const httpsMatch = url.match(/https:\/\/github\.com\/(.+?)(?:\.git)?$/);
  if (httpsMatch) {
    return httpsMatch[1];
  }

  console.error(`Error: Could not parse GitHub URL: ${url}`);
  console.error(
    "Expected format: git@github.com:owner/repo.git or https://github.com/owner/repo.git",
  );
  Deno.exit(1);
}

// Determine if we need to specify the repo explicitly
let repoArg = "";
if (!isGitRepo) {
  const originUrl = await getOriginRemote();
  const repoIdentifier = parseGitHubUrl(originUrl);
  repoArg = `--repo=${repoIdentifier}`;
}

const ghCmd = repoArg
  ? $`gh pr list ${repoArg} --search=${updatedAtFilter} --json="author,title,updatedAt,headRefOid"`
  : $`gh pr list --search=${updatedAtFilter} --json="author,title,updatedAt,headRefOid"`;

const prs = PR.array().parse(
  JSON.parse(
    await ghCmd.text(),
  ),
);

// First collect the entries so we can calculate the max width of the first column
interface Entry {
  authorWhen: string;
  title: string;
  commit: string;
}

const entries: Entry[] = prs.flatMap((pr) => {
  if (pr.author.is_bot) {
    return [];
  }

  const updatedAt = Temporal.Instant.from(pr.updatedAt.toISOString());
  const duration = updatedAt.until(now);
  const daysAgo = Math.floor(duration.total({ unit: "days" }));
  const when = daysAgo === 0 ? "today" : `${daysAgo} days ago`;
  const author = pr.author.name || pr.author.login;

  return [
    {
      authorWhen: `${author} (${when})`,
      title: pr.title,
      commit: pr.headRefOid,
    },
  ];
});

// Determine the width for the first column so that all rows line up
const maxAuthorWhenLen = entries.reduce(
  (max, { authorWhen }) => Math.max(max, authorWhen.length),
  0,
);

// Build the list: "<padded authorWhen>  <title>\t<branch>"
const list = entries
  .map(({ authorWhen, title, commit }) => {
    const paddedAuthorWhen = authorWhen.padEnd(maxAuthorWhenLen + 2); // +2 for spacing between columns
    return `${paddedAuthorWhen}${title}\t${commit}`;
  })
  .join("\n");

// Pipe the list into fzf. We hide the branch column while keeping it in the
// line so we can recover it after selection.
const selectedLine = (
  await $`fzf --ansi --delimiter="\t" --with-nth=1`.stdinText(list).noThrow(130)
    .text()
).trim();

if (selectedLine.length === 0) {
  console.error("no PR selected");
  Deno.exit(1);
}

// Extract the commit (hidden second column)
const [, commit] = selectedLine.split("\t");

await fetchPromise;
await $`jj new ${commit}`.quiet();
